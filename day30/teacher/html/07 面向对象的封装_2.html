<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>



    // 工厂模式 创建对象  (给定既定的参数 产出对象 )
    // function Cat(name, color) {
    //     var obj = {   // new Object();
    //         name: name,
    //         color: color,
    //         call() {
    //             console.log("喵喵");
    //         },
    //         skill() {
    //             console.log("捉老鼠");
    //         }
    //     }

    //     return obj;
    // }

    // 1. 通过此方法创建的对象 和 函数没有关系(对比构造函数)
    // var arr = new Array();
    // var obj = new Object();
    // console.log(arr instanceof Array); // true;
    // console.log(obj instanceof Object); // true;

    // 2. 共有的属性和方法重复创建  => 浪费内存




    // 自定义构造函数
    // !!! 构造函数中的this,指向函数调用过程中创建的实例化对象

    function Cat(name, color) {
        // {}
        // this-> {}

        // 把需要的属性和方法绑定到创建的对象(实例化对象)
        this.name = name;
        this.color = color;

        // 所有实例化对象共有的属性和方法
        // this.species = "猫";
        // this.call = function () {
        //     console.log("喵喵");
        // }
        // this.skill = function () {
        //     console.log("捉老鼠");
        // }
        // return this;
    }
    // console.dir(Cat);  //打印构造函数   => prototype(显示原型|原型对象)

    // 存
    // prototype(显示原型 | 原型对象)
    // 将所有实例化对象的公有的属性和方法,存到一个统一的位置, (供所有的实例化对象访问)
    // 只要通过该构造函数创建的实例化对象(new Cat())  都可以访问原型对象(prototype上的属性和方法)

    // 所有实例化对象共有的属性和方法  => 存到Cat.prototype(原型对象)
    Cat.prototype.species = "猫";
    Cat.prototype.call = function () {
        console.log("喵喵");
    }
    Cat.prototype.skill = function () {
        console.log("捉老鼠");
    }
    Cat.prototype.say = function () {
        console.log(this.name, this.color);
    }

    console.dir(Cat);

    var Tom = new Cat("Tom", "black");
    console.log(Tom, Tom instanceof Cat);
    console.log(Tom.__proto__ === Cat.prototype);

    // __proto__  (隐式原型|原型属性)  一般要求省略(否则this的指向会受到影响Tom.__proto__ ===Cat.prototype )
    // console.log(Tom.__proto__.species);
    // console.log(Tom.__proto__.call);
    // console.log(Tom.__proto__.skill);

    // console.log(Tom.species);
    // console.log(Tom.call);
    // console.log(Tom.skill);
    // Tom.say(); // this -> Tom

    var Kitty = new Cat("Kitty", "Pink");
    console.log(Kitty, Kitty instanceof Cat);
    console.log(Kitty.__proto__ === Cat.prototype);

    // console.log(Kitty.species);
    // console.log(Kitty.call);
    // console.log(Kitty.skill);
    // Kitty.say(); // this -> Tom







</script>

</html>