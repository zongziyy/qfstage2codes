<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 面向对象之继承
    // 让一个类(构造函数) 继承 另一个类 的属性和方法 (构造函数中的属性/方法(实例) 和 原型对象上的公用的属性和方法)

    // 继承的类  子类
    // 被继承的类 父类

    // 本质:实现属性和方法的复用


    // 组合继承(构造函数的继承 + 原型对象的继承)


    function Person(name, age) { //  构造函数中 实例的属性和方法
        // {}   this->{}
        this.name = name;    // 构造函数Person在执行时 this-> Person创建的实例化对象
        this.age = age;
        this.species = "human";
    }

    // 原型对象上的属性和方法
    Person.prototype.say = function () {
        console.log(this.name, this.age);
    }
    Person.prototype.skill = function () {
        console.log("thinking");
    }


    // 黄种人
    function YellowPerson(name, age, hobby) {
        Person.call(this, name, age);
        this.hobby = hobby;
    }

    // 中间函数  
    function Fn() { }
    Fn.prototype = Person.prototype;

    // 最简单的原型继承 (最low的 父类构造函数也会有影响)
    YellowPerson.prototype = new Fn();
    YellowPerson.prototype.constructor = YellowPerson;  // 重新定义constructor指向构造函数本身

    YellowPerson.prototype.skin = "yellow";
    YellowPerson.prototype.speak = function () {
        console.log("chinese");
    };

    console.dir(Person);

    var p1 = new YellowPerson("李四", 25, "唱歌");
    console.log(p1);

    console.log(p1.name)
    console.log(p1.age)
    console.log(p1.hobby)

    console.log(p1.skin)
    p1.speak();

    p1.say();
    p1.skill();


    // class YellowPerson extends Person { };







</script>

</html>