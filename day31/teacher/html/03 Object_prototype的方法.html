<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>



    // 工厂模式 创建对象  (给定既定的参数 产出对象 )
    // function Cat(name, color) {
    //     var obj = {   // new Object();
    //         name: name,
    //         color: color,
    //         call() {
    //             console.log("喵喵");
    //         },
    //         skill() {
    //             console.log("捉老鼠");
    //         }
    //     }

    //     return obj;
    // }

    // 1. 通过此方法创建的对象 和 函数没有关系(对比构造函数)
    // var arr = new Array();
    // var obj = new Object();
    // console.log(arr instanceof Array); // true;
    // console.log(obj instanceof Object); // true;

    // 2. 共有的属性和方法重复创建  => 浪费内存




    // 自定义构造函数
    // !!! 构造函数中的this,指向函数调用过程中创建的实例化对象

    function Cat(name, color) {
        // {}
        // this-> {}

        // 把需要的属性和方法绑定到创建的对象(实例化对象)
        this.name = name;
        this.color = color;
        // this.__proto__ = Cat.prototype
        // return this;
    }


    // 所有实例化对象共有的属性和方法  => 存到Cat.prototype(原型对象)
    // Cat.prototype.constructor = Cat;
    Cat.prototype.species = "猫";
    Cat.prototype.call = function () {
        console.log("喵喵");
    }
    Cat.prototype.skill = function () {
        console.log("捉老鼠");
    }
    Cat.prototype.say = function () {
        console.log(this.name, this.color);
    }

    console.dir(Cat);

    Object.prototype.a = 1;
    Object.prototype.b = 2;

    var Tom = new Cat("Tom", "black");
    console.log(Tom);

    // Tom => Tom.__proto__(Cat.prototype) =>Cat.prototype.__proto__ (Object.prototype) =>null
    // Tom =>  Cat.prototype =>  Object.prototype => null

    // instanceof     判断的一个对象(实例对象)的原型链上是否包含构造函数的原型对象(prototype)
    // console.log(Tom instanceof Cat);
    // console.log(Tom instanceof Object);
    // console.log(Tom instanceof Array);

    // isPrototypeOf    判断的是 构造函数的原型对象 是否存在于 实例对象 的原型链之上
    // console.log(Cat.prototype.isPrototypeOf(Tom));
    // console.log(Object.prototype.isPrototypeOf(Tom));

    // in    判断的一个对象(实例对象)的原型链上是否存在某个属性
    // Tom =>  Cat.prototype =>  Object.prototype => null
    // console.log("name" in Tom);  // "name" 是否存在于 Tom的原型链上 
    // console.log("species" in Tom);  // "name" 是否存在于 Tom的原型链上 
    // console.log("a" in Tom);  // "name" 是否存在于 Tom的原型链上 

    // for (var key in Tom) {
    //     console.log(key);
    // }

    // hasOwnProperty    在实例中是否包含该属性，不在原型链中查找该属性
    // console.log(Tom.hasOwnProperty("name"));  //true
    // console.log(Tom.hasOwnProperty("species")); // false
    // console.log(Tom.hasOwnProperty("a")); // false

    // propertyIsEnumerable 方法返回一个布尔值，表示指定的属性是否可枚举(遍历)。 (只查找实例本身,不在原型链中查找)

    console.log(Tom.propertyIsEnumerable("name")); // true
    console.log(Tom.propertyIsEnumerable("color")); // true
    console.log(Tom.propertyIsEnumerable("species")); // true
    console.log(Tom.propertyIsEnumerable("a")); // true








</script>

</html>